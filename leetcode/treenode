#include "treenode.h"
#include "stringtool"
#include <cstdio>
#include <sstream>
#include <queue>
#include <vector>
#include <stack>
namespace ymh {
template<class T>
GenericTreeNode<T>::GenericTreeNode(T x) : val(x), left(nullptr), right(nullptr) {}

/*
construct a Tree from string
{1, #, 2, 3}
[1,null,2, 3] --> 1
                 / \
                    2
                   / \
                   3
Note: make sure you use the right method to get input
 `getline(cin, input)` is better than `cin >> input`
*/
template<class T>
GenericTreeNode<T> *GenericTreeNode<T>::stringToTreeNode(std::string input) {
    trimLeftTrailingSpaces(input);
    trimRightTrailingSpaces(input);
    input = input.substr(1, input.length() - 2);
    if (input.empty()) {
        return nullptr;
    }

    std::string item;
    std::stringstream ss(input);

    getline(ss, item, ',');
    auto root = new GenericTreeNode(stringToValue<T>(item));
    std::queue<GenericTreeNode *> nodeQueue;
    nodeQueue.push(root);

    while (true) {
        GenericTreeNode *node = nodeQueue.front();
        nodeQueue.pop();
        item.clear();
        if (!getline(ss, item, ',')) {
            break;
        }

        trimLeftTrailingSpaces(item);
        trimRightTrailingSpaces(item);
        if (item != "null" && item != "#") {
            auto leftNumber = stringToValue<T>(item);
            node->left = new GenericTreeNode(leftNumber);
            nodeQueue.push(node->left);
        }

        item.clear();
        if (!getline(ss, item, ',')) {
            break;
        }

        trimLeftTrailingSpaces(item);
        trimRightTrailingSpaces(item);
        if (item != "null" && item != "#") {
            auto rightNumber = stringToValue<T>(item);
            node->right = new GenericTreeNode(rightNumber);
            nodeQueue.push(node->right);
        }
    }
    return root;
}

template<class T>
std::vector<T> GenericTreeNode<T>::preorderTraverse(GenericTreeNode *root) {
    std::vector<T> ans;
    if (root == nullptr) {
        return ans;
    }
    std::stack<GenericTreeNode *> s;
    s.push(root);
    while (!s.empty()) {
        GenericTreeNode *node = s.top();
        s.pop();
        ans.push_back(node->val);
        if (node->right != nullptr) {
            s.push(node->right);
        }
        if (node->left != nullptr) {
            s.push(node->left);
        }
    }
    return ans;
}

template<class T>
std::vector<T> GenericTreeNode<T>::inorderTraverse(GenericTreeNode *root) {
    std::vector<T> ans;
    std::stack<GenericTreeNode*> stack;
    GenericTreeNode *node = root;
    while (node != nullptr || !stack.empty()) {
        while (node != nullptr) {
            stack.push(node);
            node = node->left;
        }
        node = stack.top();
        stack.pop();
        ans.push_back(node->val);
        node = node->right;
    }
    return ans;
}

template<class T>
std::vector<T> GenericTreeNode<T>::postorderTraverse(GenericTreeNode *root) {
    std::vector<T> ans;
    std::stack<GenericTreeNode*> stack;
    GenericTreeNode *node = root, *last_visited = NULL;
    while (node != NULL || !stack.empty()) {
        while (node != NULL) {
            stack.push(node);
            node = node->left;
        }
        node = stack.top();
        if (node->right == NULL || node->right == last_visited) {
            stack.pop();
            ans.push_back(node->val);
            last_visited = node;
            node = NULL;
        }
        else {
            node = node->right;
        }
    }
    return ans;
}
}